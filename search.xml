<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[cookie、sessionStorage和localStorage的区别]]></title>
      <url>%2F2017%2F04%2F13%2Fcookie%E3%80%81sessionStorage%E5%92%8ClocalStorage%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[cookie介绍：早期设计用于服务端存储少量数据的，任何以cookie形式存储的数据，不论服务器端是否需要，每一次HTTP请求都会把这些数据传输到服务器。 用处：用于保存状态以及能够为浏览器提供身份识别机制。注意，js中不会对cookie采用任何加密机制（只有通过https协议来传输cookie则是安全的）。 有效期：默认浏览器关闭后删除cookie，可通过设置max-age（单位是秒）来设置cookie的有限期。 作用域：默认对创建cookie的页面以及和该页面同目录或者子目录下的其他网页可见。修改作用域参考cookie的path和domain属性。 局限性：每个cookie保存的数据（名字和值的总量）不能超过4KB，浏览器保存的cookie不能超过300个，服务器保存的cookie不能超过20个。 sessionStorage和localStorage介绍：两者都代表同一个Storage对象，它们的区别仅仅在于存储的有限期和作用域的不同，即数据可以存储多少时间以及谁拥有数据的访问权。 区别：localStorage存储的数据是永久性的，永不过期；localStorage存储的数据仅限于当前标签页或最顶层的窗口，一旦标签页或窗口被关闭，数据随即被删除。 作用域：localStorage和localStorage的作用域都是限定在文档源级别的。（文档源 = 协议 + 主机名 + 端口）只有同源文档才可以共享数据。另外，同源前提下的不同标签页中的sesstionStorage无法共享。 存储API： localStorage.setItem(&apos;x&apos;, 1); // 存储某项的值 localStorage.getItem(&apos;x&apos;); // 获取某项的值 localStorage.removeItem(&apos;x&apos;); // 删除具体项 localStorage.clear(); // 全部清楚]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解JS中的call和apply]]></title>
      <url>%2F2017%2F03%2F14%2F%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84call%E5%92%8Capply%2F</url>
      <content type="text"><![CDATA[存在即合理，首先了解下call和apply存在的作用。 JS中函数存在 定义时上下文 和 运行时上下文，并且上文是可以动态改变的。 call 和apply 都是为了改变函数运行时的context（即上下文）而存在的。换句话说，就是为了改变函数体内部this的指向。 定义一个宠物对象，其拥有words属性和say函数： var pet = { words:&apos;...&apos;, say:function(){ console.log(&apos;Say:&apos; + this.words) } } pet.say() //&quot;Say: ...&quot; 每个宠物有不同的叫声，如果我们定义一个对象： var cat = { words:&apos;miao&apos; } 在不重写say方法的条件下，我们希望通过pet对象使它能拥有自己的叫声miao，只需要利用call或者apply改变pet里面的this的指向，将this指向cat即可： pet.say.call(cat) //&quot;Say:miao&quot; pet.say.apply(cat) //&quot;Say:miao&quot; 二者作用一样，唯一的区别是接收参数的形式不一样： obj.call(thisObj, arg1, arg2, ...) //接受的是连续参数。 obj.apply(thisObj, [arg1, arg2, ...]) //接受的是数组参数 通过call和apply，可以实现对象的继承： var parent = function{ this.name = &apos;pjx&apos; this.sex = &apos;boy&apos; } var child = {}; console.log(child);//{} parent.call(child); console.log(child); //{name: &quot;pjx&quot;, sex: &apos;boy&apos;}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用vue.js的proxyTable解决跨域问题]]></title>
      <url>%2F2017%2F03%2F10%2F%E4%BD%BF%E7%94%A8vue%E7%9A%84proxyTable%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[当前端工程师搭建好页面开始与后端进行联调时，总是会面对跨域的问题：No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:8080‘ is therefore not allowed access.” 解决办法：进入你的vue项目下 -&gt; config -&gt; index.js，里面的dev对象下有一个proxyTable的属性，这个参数主要是一个地址映射表，可以帮助我们将复杂的url简化。 如要请求的地址是api.xxx.com/list/1，可以对proxyTable进行如下配置： proxyTable: { &apos;/list&apos;: { target: &apos;http://api.xxx.com&apos;, pathRewrite: { &apos;^/list&apos;: &apos;/list&apos; } } } 如此一来就可以用/list/1来代替api.xxx.com/list/1。 那么又是如何解决跨域问题的呢？其实在上面的’list’的参数里有一个changeOrigin参数，接收一个布尔值，如果设置为true,那么本地会虚拟一个服务端接收你的请求并代你发送该请求，这样就不会有跨域问题了，当然这只适用于开发环境。增加的代码如下所示： proxyTable: { &apos;/list&apos;: { target: &apos;http://api.xxxxxxxx.com&apos;, changeOrigin: true, pathRewrite: { &apos;^/list&apos;: &apos;/list&apos; } } } 如果想要一套代码兼容开发和生产环境，避免在开发环境和生产环境之间切换时，频繁修改接口调用的代码。可以作如下判断： let urlApi = &apos;&apos; let url = window.location.href if(url.indexOf(&apos;8080&apos;) &gt; -1){ urlApi = &apos;/list/1/xxx&apos; }else{ urlApi = &apos;http://api.xxxxxxxx.com/1/xxx&apos; } 参考文档：https://vuejs-templates.github.io/webpack/proxy.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS数组常用操作]]></title>
      <url>%2F2017%2F02%2F09%2FJS%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[创建数组new Array(); new Array(size); new Array(a,b,c...); concat连接两个或更多的数组，并返回结果。 var a = [1,2,3]; console.log(a.concat(4,5,6));//[1, 2, 3, 4, 5, 6] console.log(a);//[1, 2, 3] join把数组的所有元素放入一个字符，并通过指定的分隔符分隔。 var a = new Array(3); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; a[2] = &quot;xun&quot;; console.log(a.join(&quot;-&quot;));//peng-jia-xun console.log(a);//[&quot;peng&quot;, &quot;jia&quot;, &quot;xun&quot;] pop删除并返回数组的最后一个元素。 var a = new Array(3); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; a[2] = &quot;xun&quot;; console.log(a.pop());//xun console.log(a);//[&quot;peng&quot;, &quot;jia&quot;] push向数组的末尾添加一个或更多元素，并返回新的长度。 var a = new Array(2); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; console.log(a.push(&quot;xun&quot;));//3 console.log(a);//[&quot;peng&quot;, &quot;jia&quot;,&quot;xun&quot;] reverse颠倒数组中元素的顺序。 var a = new Array(3); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; a[2] = &quot;xun&quot;; console.log(a.reverse());//[&quot;xun&quot;, &quot;jia&quot;, &quot;peng&quot;] console.log(a);//[&quot;xun&quot;, &quot;jia&quot;, &quot;peng&quot;] shift删除并返回数组的第一个元素。 var a = new Array(3); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; a[2] = &quot;xun&quot;; console.log(a.shift());//peng console.log(a);//[&quot;jia&quot;,&quot;xun&quot;] unshift向数组的开头添加一个或更多元素，并返回新的长度。 var a = new Array(2); a[0] = &quot;jia&quot;; a[1] = &quot;xun&quot;; console.log(a.unshift(&quot;peng&quot;));//3 console.log(a);//[&quot;peng&quot;, &quot;jia&quot;, &quot;xun&quot;] slice从某个已有的数组返回选定的元素。 var a = new Array(3); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; a[2] = &quot;xun&quot;; console.log(a.slice(1));//[&quot;jia&quot;, &quot;xun&quot;] console.log(a.slice(0,2));//[&quot;peng&quot;, &quot;jia&quot;] console.log(a);//[&quot;peng&quot;, &quot;jia&quot;, &quot;xun&quot;] sort对数组的元素进行排序。 var a = new Array(3); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; a[2] = &quot;xun&quot;; console.log(a.sort());//[&quot;jia&quot;, &quot;peng&quot;, &quot;xun&quot;] console.log(a);//[&quot;jia&quot;, &quot;peng&quot;, &quot;xun&quot;] splice删除元素，并向数组添加新元素，然后返回被删除的项目。 var a = new Array(3); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; a[2] = &quot;xun&quot;; console.log(a.splice(1,1,&quot;xiao&quot;));//[&quot;jia&quot;] console.log(a);//[&quot;peng&quot;, &quot;xiao&quot;, &quot;xun&quot;] toString把数组转换为字符串，并返回结果。 var a = new Array(3); a[0] = &quot;peng&quot;; a[1] = &quot;jia&quot;; a[2] = &quot;xun&quot;; console.log(a.toString());//peng,jia,xun console.log(a);//[&quot;peng&quot;, &quot;jia&quot;, &quot;xun&quot;]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS去除字符串空格的两种方法]]></title>
      <url>%2F2016%2F12%2F19%2FJS%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A9%BA%E6%A0%BC%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[在用户填写登录表单的时候，由于用户输入的不确定性，可能会出现在输入用户名的时候，其前后有空格的情况。这就需要我们对其进行修正。 解决方法：方法1: js加正则表达式来构造trim函数 function trim(str){ return str.replace(/^\s*|\s*$/g,&apos;&apos;);//全局匹配,字符串开始或结尾的所有空字符 } var str = &quot; 前后各有两个空格 &quot;; var tem = trim(str); console.log(str.length);//12 console.log(tem.length);//8 注意：如果浏览器本身就实现了js的trim函数，则可以直接使用xxx.trim()操作，如果浏览器没实现(如ie)，只能用以上正则替换。 方法2:jquery的$.trim //先引入jquery库，再使用 var str = $.trim(&quot; 前后各有两个空格 &quot;); console.log(str);//&quot;前后各有两个空格&quot; jquery的trim函数具有良好的浏览器兼容性，推荐使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown简明语法教程]]></title>
      <url>%2F2016%2F11%2F25%2FMarkdown%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[标题# h1 ## h2 ### h3 ... ###### h6 引用&gt;这是 &gt;一段 &gt;引用 或者只在第一行标注 &gt;这是 一段 引用 引用内可以嵌套引用或其他markdown语法 &gt; &gt; 引用内的引用 &gt; # 这是标题 有序列表1. First 2. Second 3. Third 无序列表* Red * Green * Blue 或者 + Red + Green + Blue 或者 - Red - Green - Blue 代码区块缩进4个空格或者一个制表符 行内代码加反引号 ` This is `code`. 分隔线三个以上的星号、减号、底线 *** --- ___ 链接[百度](http://www.baidu.com &quot;Title&quot;) 强调*em* _em_ **strong** __strong__ 图片![Alt text](/img/img.jpg &quot;Title&quot;) 自动链接在html中会自动转换成a标签形式 &lt;www.baidu.com&gt; &lt;address@example.com&gt; 反斜杠在以下符号前加反斜杠即插入普通符号 \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Selenium+Java前端自动化测试教程]]></title>
      <url>%2F2016%2F11%2F24%2FSelenium-Java%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[一、工具准备 Firefox浏览器（版本要求47以下，本教程版本为45.5，记得关掉它的自动更新。） JDK-1.8 Eclipse 二、环境搭建·配置Selenium RC 下载 selenium-server-standalone-3.0.1下载地址 http://www.seleniumhq.org/download/ 启动selenium服务：将下载的zip包解压，然后在命令行进入解压文件的目录，输入java -jar seleniun-server-standalone-3.0.1.jar如图所示表示启动服务成功： ·配置Selenium Webdriver 下载 selenium-java-3.0.1下载地址 http://www.seleniumhq.org/download/ 在Eclipse中新建Java Project 如图操作，导入所需jar包 ·下载selenium3使用firefox时所需的驱动下载地址 https://github.com/mozilla/geckodriver/releases/tag/v0.9.0至此，项目环境搭建完成。 三、测试示例新建一个名为test.java 的文件。实现效果：打开百度首页，输入“Selenium”，点击搜索。 package test; import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; public class baidu { public static void main(String[] args){ //引入geckodriver驱动 System.setProperty(&quot;webdriver.firefox.marionette&quot;,&quot;C:\\Users\\Jaden\\Desktop\\Test\\jar\\geckodriver.exe&quot;); //新建一个firefox浏览器实例 WebDriver driver = new FirefoxDriver(); //打开百度首页 driver.get(&quot;http://www.baidu.com&quot;); //根据id获取输入框 WebElement textInput = driver.findElement(By.id(&quot;kw&quot;)); //在输入框输入“Selenium” textInput.sendKeys(&quot;Selenium&quot;); //根据id获取“百度一下”按钮 WebElement submit = driver.findElement(By.id(&quot;su&quot;)); //点击按钮 submit.click(); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的not defined和undefined]]></title>
      <url>%2F2016%2F11%2F23%2FJS%E4%B8%AD%E7%9A%84not%20defined%E5%92%8Cundefined%2F</url>
      <content type="text"><![CDATA[JS中关于变量常遇到的错误有两个，一个是“xx is not defined”,另一个是“undefined”。 一.区别1.”not defined” var a;//只声明变量，未赋值 console.log(a);//undefined 2.”undefined” //var a; console.log(a);//未声明变量且未赋值，a is not defined 结论：声明变量却没有对其进行赋值，即变量undefined;未声明也未赋值变量，即变量not defined.undefined:不明确的，也就是不知道用来干嘛的;not defined: 未定义的. 注：若变量a没有通过var声明，但是却赋值了，如： a = 1; console.log(a);//1 console.log(window.a)//1 当变量不加var声明时，默认在变量前面自动添加window.，也就成了window的属性。 再看一个例子： (function aa(){ var a = 1; b = 2; })(); console.log(a);//a is not defined console.log(window.a);//undefined console.log(b);//2 console.log(window.b);//2 结论：如果在方法中声明变量，则为局部变量.如果是在全局域中声明，则为全局变量. 二.判断两者都可以用typeof进行判断: var a; if (typeof(a) == &quot;undefined&quot;) { alert(&quot;undefined&quot;); } if (typeof(b) == &quot;undefined&quot;) { alert(&quot;undefined&quot;); } 三.null既然提到not defined和undefined，有一个不得不提的就是null了。 console.log(typeof(null));//Object null是js的关键字，其含义为“非对象”。不过通常认为它是null这个类型下的唯一一个成员，它可以表示数字、字符和对象是“无值”的 undefined也是表示无值 console.log(null == undefined);//true console.log(null === undefined);//false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[超简单的Java发送邮件教程]]></title>
      <url>%2F2016%2F11%2F21%2F%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84Java%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%95%99%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Java代码实现网易邮箱发送邮件教程 一. 下载并添加mail.jar包到项目中这里不附送下载链接，百度一下，你就知道。 二. 设置邮箱这里以网易邮箱为例 1.进入“设置”菜单，选择“POP3/SMTP/IMAP” 2.勾选下列选项，按照提示设置授权码。（记住授权码，后面代码要用到） 三. 代码示例import java.util.Properties; import javax.mail.Authenticator; import javax.mail.Message.RecipientType; import javax.mail.MessagingException; import javax.mail.PasswordAuthentication; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeMessage; public class mail163 { public void main(String msg){ // 创建Properties 类用于记录邮箱的一些属性 Properties props = new Properties(); // 表示SMTP发送邮件，必须进行身份验证 props.put(&quot;mail.smtp.auth&quot;,&quot;true&quot;); //此处填写SMTP服务器 props.put(&quot;mail.smtp.host&quot;, &quot;smtp.163.com&quot;); //端口号，网易邮箱端口号为25 props.put(&quot;mail.smtp.port&quot;, &quot;25&quot;); // 此处填写你的账号 props.put(&quot;mail.user&quot;, &quot;xxx@163.com&quot;); // 此处的密码就是前面说的授权码 props.put(&quot;mail.password&quot;, &quot;xxx&quot;); // 构建授权信息，用于进行SMTP进行身份验证 Authenticator authenticator = new Authenticator() { protected PasswordAuthentication getPasswordAuthentication() { // 用户名、密码 String userName = props.getProperty(&quot;mail.user&quot;); String password = props.getProperty(&quot;mail.password&quot;); return new PasswordAuthentication(userName, password); } }; // 使用环境属性和授权信息，创建邮件会话 Session mailSession = Session.getInstance(props, authenticator); // 创建邮件消息 MimeMessage message = new MimeMessage(mailSession); // 设置发件人 InternetAddress form = null; try { form = new InternetAddress(props.getProperty(&quot;mail.user&quot;)); message.setFrom(form); // 设置收件人的邮箱 InternetAddress to = null; to = new InternetAddress(&quot;xxx@163.com&quot;); message.setRecipient(RecipientType.TO, to); // 设置邮件标题 message.setSubject(&quot;测试邮件&quot;); // 设置邮件的内容体 message.setContent(msg, &quot;text/html;charset=UTF-8&quot;); // 最后，发送邮件 Transport.send(message); System.out.println(&quot;邮件已发送,请查收！&quot;); } catch (MessagingException e) { e.printStackTrace(); } } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac远程桌面连接window证书或相关链接无效]]></title>
      <url>%2F2016%2F11%2F21%2Fmac%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5window%E8%AF%81%E4%B9%A6%E6%88%96%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5%E6%97%A0%E6%95%88%2F</url>
      <content type="text"><![CDATA[要想通过mac远程连接到window，首先要安装mac的远程桌面连接软件，安装教程传送门：点我 安装好后，远程连接却报错，错误信息是“证书或相关链接无效”。 解决方法 在远程连接的window系统里，命令行输入gpedit.msc回车，进入“本地组策略编辑器”； 依次找到 计算机配置 - 管理模板 - Windows 组件 - 远程桌面服务 - 远程桌面会话主机 - 安全 - 远程（RDP）连接要求使用指定的安全层，如下图： 打开 远程（RDP）连接要求使用指定的安全层，如下图进行设置即可：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决表单提交时中文unable to decode value]]></title>
      <url>%2F2016%2F11%2F21%2F%E8%A7%A3%E5%86%B3%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4unable%2F</url>
      <content type="text"><![CDATA[如果网页的页面编码是gb2312，而后端接收的编码是utf-8，提交含有中文值的表单时，就会报unable to decode value的错误，如下图：原本想通过js对提交的值进行编码转换操作，网上查了一下，原来form表单自带有一个“accept-charset”属性，通过它可以设置服务器处理表单的字符格式。所以只需要在要提交的表单加上accept-charset=”utf-8”即可解决]]></content>
    </entry>

    
  
  
</search>
